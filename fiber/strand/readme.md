# Strand

## Пререквизиты

- [fiber/mutex](/tasks/fiber/mutex)
- [sched/intrusive](/tasks/sched/intrusive)
- интрузивная реализация примитивов синхронизации

## Mutex

С точки зрения протокола когерентности кэшей, синхронный мьютекс – неэффективный примитив синхронизации:

Чем больше число ядер, на которых исполняются критические секции, тем выше накладные расходы на когерентность, так как разделяемые данные, к которым обращаются критические секции, приходится постоянно двигать между ядрами.

## Mutex → Strand

Гораздо разумнее "двигать" не данные между ядрами к критическим секциям, а наоборот
– критические секции собрать на одном ядре и выполнить их серией, одну за другой.

Внутри серии коммуникация между ядрами не будет: данные будут во владении текущего ядра.

Так и будет работать `Strand`:

```cpp
void StrandExample() {
  using namespace exe;  // NOLINT
  
  sched::ThreadPool scheduler{4};
  scheduler.Start();
  
  thread::WaitGroup example;
  example.Add(1);
  
  fiber::Go(scheduler, [&] {
    fiber::WaitGroup wg;
    
    // Strand реализует взаимное исключение для файберов
    fiber::Strand mutex;
    
    size_t cs = 0;
    
    for (size_t i = 0; i < 128; ++i) {
      wg.Add(1);
      
      fiber::Go([&] {
        Defer defer([&] {
          wg.Done();
        });
        
        for (size_t j = 0; j < 1024; ++j) {
          // Выполняем критическую секцию
          // или ждем, пока другой вызов Combine не выполнит ее за нас:
          mutex.Combine([&] {
            // Тело критической секции
            ++cs;
          });
          // <- Критическая секция выполнена
        }
      });
    }
    
    wg.Wait();
    
    fmt::println("# critical sections = {}", cs);
    
    example.Done();
  });
  
  example.Wait();
  
  scheduler.Stop();
}
```

Чем больше будет нагрузка на `Strand`, тем **меньше** будет в исполнении синхронизации, и тем эффективнее будут исполняться критические секции пользователей!

#### `Combine`

`Strand` не похож на _BasicLockable_, вместо методов `Lock` и `Unlock` у него – единственный метод `Combine`, который получает аргументом тело критической секции.
 
Метод `Combine` – синхронный: если он вернул файберу управление, то критическая секция выполнена.

Файбер, вызывающий `Combine`, либо сам выполняет свою критическую секцию, либо ждет (не блокируя поток планировщика), пока эту секцию не исполнит другой файбер в своем вызове `Combine`.

### Ограничения 

Критическая секция одного файбера может исполняться другим файбером, так что запретим пользователю останавливать текущий файбер в критической секции.

(Опционально) Напишите и используйте `NoContextSwitchGuard`, который запрещает файберу переключать контекст в данном лексическом скоупе. 

## Реализация

### Серии

`Strand` должен исполнять секции _сериями_ или _пакетами_ (_batching_).

Серии должны адаптироваться под нагрузку:

- Чем больше нагрузка на `Strand`, тем больше должны быть серии и тем меньше должно быть в исполнении синхронизации. Серии могут получаться сколь угодно большими, но все же должны оставаться конечными.
- При этом `Strand` не должен искусственно задерживать исполнение критических секций.

Исполнять критические секции должны сами пользователи `Strand`, т.е. файберы, вызывающие `Combine`. 

Файбер, исполняющий серию критических секций, мы назовем _combiner_, а саму технику – _combining_.

### Аллокации

`Strand` не должен динамически аллоцировать память.

## Strand → Mutex

Идею серийного исполнения критических секций можно реализовать прямо в _Lockable_ [`Mutex`](exe/fiber/sync/mutex.hpp), отдельный примитив и изменение API для этого не требуется!

Но для хорошей реализации серийного `Mutex` нужно будет доработать 
- либо файберы – поддержать для них механизм симметричной передачи управления,
- либо планировщик – шардировать его и поддержать LIFO планирование.

## Задание

1) Напишите серийный [`Strand`](exe/fiber/sync/strand.hpp)
2) Убедитесь, что он выигрывает по пропускной способности у `Mutex`   
3) Напишите лок-фри реализацию `Strand` (очередь на двух стеках?)
4) Вернитесь в задачу [fiber/mutex](/tasks/fiber/mutex) и напишите серийный лок-фри `Mutex`
