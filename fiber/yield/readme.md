# Fibers, Oh My!

## Пререквизиты

- [sched/thread_pool](/tasks/sched/thread_pool)
- [fiber/coro](/tasks/fiber/coro)

---

В этой задаче мы напишем многопоточные кооперативные файберы.

Планировщик для файберов нами [уже реализован](/tasks/sched/thread_pool), это пул потоков.

Механизм остановки / возобновления исполнения – [тоже](/tasks/fiber/coro), это stackful корутина.

Остается лишь скомбинировать их!

## Файберы

Результат будет выглядеть так:

```cpp
void FibersExample() {
  // В этой задаче мы начнем писать свой фреймворк для concurrency
  // Он будет называться `exe` (от execution)
  using namespace exe;

  // Пул потоков будет служить планировщиком для файберов
  sched::ThreadPool scheduler{4};
  scheduler.Start();
  
  thread::WaitGroup wg;

  for (size_t i = 0; i < 128; ++i) {
    wg.Add(1);
    // Планируем файбер в пул потоков
    fiber::Go(scheduler, [&wg] {
      // https://go.dev/tour/flowcontrol/12
      Defer defer([&wg] {
        wg.Done();
      });
      
      for (size_t j = 0; j < 7; ++j) {
        // Уступаем поток планировщика другому файберу
        fiber::Yield();
      }
    });
  }
  
  // Файберы исполняются _параллельно_ на потоках пула

  // Дожидаемся завершения файберов
  wg.Wait();
  
  // Выключаем планировщик
  scheduler.Stop();
}  
```

См. [play/main.cpp](play/main.cpp)

## API

В этой задаче мы поддержим лишь основные «системные вызовы» к планировщику ([fiber/sched](exe/fiber/sched)):

- `void Go(Scheduler&, Body)` – запланировать процедуру на исполнение в файбере в заданный планировщик
- `void Go(Body)` – запланировать процедуру на исполнение в файбере в текущий планировщик (т.е. из файбера)
- `void Yield()` – перепланировать текущий файбер, уступить поток планировщика другим файберам

Позже мы научим файберы синхронизации.

## Дизайн

_Файбер_ = _Корутина_ × _Планировщик_

Два измерения в этой формуле должны оставаться ортогональными:

- _Планировщик_ (пул потоков) не знает про файберы и корутины, его единственная ответственность – исполнять _задачи_. 
- _Корутина_ не знает про планировщики и потоки, не знает про кооперативную многозадачность, она лишь реализует suspendable процедуру.

Файберы наделяют абстрактные понятия _задача_ и _корутина_ конкретным смыслом: кооперативная многозадачность.

Реализация файберов
- генерирует служебные задачи для планировщика,
- возобновляет и останавливает в них корутины, исполняющие процедуры пользователей.


## Структура `exe`

- [`sched`](exe/sched) – планировщики (пока – только `ThreadPool`)
- [`fiber`](exe/fiber) – кооперативные файберы
    - `sched` – планирование (`Go`, `Yield`, ...)
    - `sync` – синхронизация (`Mutex`, `WaitGroup`, ...)
- [`thread`](exe/thread) – синхронизация для потоков (`Mutex`, `WaitGroup`, ...)
- [`util`](exe/util) – полезные мелочи

## References

- [Fibers, Oh My!](https://graphitemaster.github.io/fibers/)
- [Project Loom: Fibers and Continuations for the Java Virtual Machine](https://cr.openjdk.java.net/~rpressler/loom/Loom-Proposal.html), [Ron Pressler and Alan Bateman – Project Loom](https://www.youtube.com/watch?v=J31o0ZMQEnI)

## Задание

1) [Перенесите](exe/sched/thread_pool.hpp) реализацию пула потоков из задачи [sched/thread_pool](/tasks/sched/thread_pool)
2) [Перенесите](exe/fiber/core/coroutine.hpp) реализацию корутины из задачи [fiber/coro](/tasks/fiber/coro)
3) Через `ThreadPool` и `Coroutine` выразите [файберы](exe/fiber/)

Код эволюционирует, так что по пути потребуются косметические изменения: нужно будет двигать файлы, корректировать инклюды, оборачивать код в дополнительные пространства имен и т.п.

## Замечания по реализации

### `Fiber`

Аллоцируйте файберы на куче.

Не используйте умные указатели для контроля времени жизни файбера. Такой подход не будет работать
с очередями ожидания в примитивах синхронизации, которые появятся в будущих задачах.

[Is it legal (and moral) for a member function to say `delete this`?](https://isocpp.org/wiki/faq/freestore-mgmt#delete-this)

### `Coroutine`

Мы будем применять корутины только для реализации файберов и не предполагаем 
их прямого использования клиентом фреймворка.

Вы можете адаптировать API корутины под нужды файберов.

### `Stack`

Файберы должны поддерживать запуск в режиме изолированной детерминированной симуляции в [Twist](https://gitlab.com/Lipovsky/twist).

Поэтому вместо `sure::Stack` (который аллоцирует страницы памяти напрямую у операционной системы с помощью `mmap`) используйте объявление стека из [`fiber/core/stack.hpp`](exe/fiber/core/stack.hpp).

### Планировщик

Вместо `ThreadPool::Current` храните ссылку на планировщик прямо в полях файбера.

В будущем мы обобщим пул потоков до абстрактного планировщика, и тогда аналогичный метод написать / использовать уже не получится.

### Границы

Класс `Fiber` не должен быть виден пользователю через публичное API.