# Treiber Stack

В этой задаче мы напишем [лок-фри MPMC стек Трeйбера](https://en.wikipedia.org/wiki/Treiber_stack).

## Подсчет ссылок

Для управления памятью будем использовать подсчет ссылок:

Свяжем с каждым узлов в стеке атомарный счетчик ссылок.

Поток, читающий `top_` в операции `TryPop`, будет увеличивать счетчик ссылок узла и тем самым защищать его от удаления из других потоков (но не от извлечения из стека).

При завершении попытки (удачной или неудачной) в операции `TryPop` поток уменьшает счетчик ссылок узла. 

Поток, который опускает счетчик ссылок до нуля, удаляет узел (отдает память аллокатору).

Нужен ли инкремент счетчика в операции `Push`?

### Наивный

Если хранить счетчик ссылок на узел непосредственно в самом узле, то мы столкнемся с проблемой:

В `TryPop` нужно
1) прочесть `top_` и 
2) увеличить счетчик узла, на который указывает `top_`.

Но между этими шагами другой поток может извлечь и удалить узел, счетчик которого мы хотели увеличить.

Так что чтение `top_` и инкремент счетчика ссылок для вершины стека (которую мы не знаем до чтения) нужно выполнять **атомарно**.

### Дифференцированный

[Differential Reference Counting](https://www.1024cores.net/home/lock-free-algorithms/object-life-time-management/differential-reference-counting)

Разделим счетчик ссылок для каждого узла на две компоненты:

- _inner count_ – хранится **в узле**, аккумулирует все **декременты** + (eventually) все **инкременты**,
- _outer count_ – аккумулирует все **инкременты**, хранится прямо  **на указателе** (_stamped pointer_, в одном машинном слове) на узел.

За счет хранения _outer count_ прямо на указателе мы можем атомарно прочитать указатель на голову стека и инкрементировать ее счетчик.

### `AtomicStampedPtr`

Для реализации нам потребуется класс [`AtomicStampedPtr<T>`](stamped_ptr.hpp).

`AtomicStampedPtr<T>` хранит указатель + 16-битный счетчик в виде одного машинного слова и умеет выполнять над этой парой стандартные атомарные операции:

```cpp
AtomicStampedPtr<T> asp({nullptr, 0});

// Записываем в `asp` пару (указатель, счетчик)
asp.Store({raw_ptr, 7});

// Читаем указатель в виде `StampedPtr` c полями `raw_ptr` и `stamp`
// В операциях можно указывать std::memory_order, по умолчанию – std::memory_order::seq_cst
StampedPtr<T> stamped_ptr = asp.Load(std::memory_order::acquire);

// Метод `IncrementStamp` возвращает _новый_ `StampedPtr`, 
// в котором счетчик увеличен на единицу
bool succeeded = asp.CompareExchangeWeak(stamped_ptr, stamped_ptr.IncrementStamp());
```

См. [unit-тесты](tests/stamped_ptr/unit.cpp) для примеров применения.

#### Stamp

Счетчик в `[Atomic]StampedPtr` не имеет самостоятельного смысла. В этой задаче мы будем использовать его для хранения _outer count_ головы стека.

### `AtomicSharedPtr`

В задаче [lf/atomic_shared_ptr](/tasks/lf/atomic_shared_ptr) мы обобщим идею с разделением счетчика на компоненты
и сможем отделить механизм управления памятью от конкретной структуры данных.
