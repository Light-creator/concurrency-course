# Work-Stealing Queue

Реализуйте [`WorkStealingQueue`](work_stealing_queue.hpp), которая послужит локальной очередью задач для потоков-воркеров [шардированного планировщика](/tasks/sched/ws_thread_pool).

## Структура

Очередь имеет фиксированную емкость и организована как циклический буфер. 

Емкость очереди задается через параметр шаблона.

Очередь хранит указатели на задачи, а не сами задачи.

## Операции

- `bool TryPush(Task* task)` – если в очереди есть свободные слоты, то добавить `task` в хвост очереди и вернуть `true`. Если очередь переполняется, то вернуть `false`.
- `Task* TryPop()` – извлечь `Task` (указатель) из головы очереди. Если очередь пуста, то вернуть `nullptr`.
- `size_t Grab(std::span<Task*> out_buffer)` – забрать пачку задач из головы очереди, переложив их в `out_buffer`, вернуть число извлеченных задач.

Метод `Grab` представлен в API поскольку реализуется эффективнее (требует меньше синхронизации), чем серия `TryPop`.

Для тестирования очереди поддержите метод `size_t SpaceLowerBound()`, который возвращает оценку на число свободных слотов в буфере. Метод будет вызываться только потоком, который владеет очередью.

## Паттерн доступа

Вариация _Single Producer_ / _Multiple Consumers_:
- Методы `TryPush` и `TryPop` вызывает только один выделенный поток.
- Метод `Grab` могут вызывать конкурентно (с другими `Grab` и `TryPop` / `TryPush`) нескольких потоков.

## Требования

- Гарантия прогресса – лок-фри
- Оптимальные `memory_order`-ы
- Нет (практически реализуемого) сценария ABA

## Применение

В шардированном планировщике
- В очереди хранятся указатели на интрузивные задачи.
- Методы `TryPush` и `TryPop` вызывает поток-воркер, владеющий очередью.
- Метод `Grab` используется при балансировке нагрузки:
  * другими воркерами для воровства задач,
  * самим воркером для выгрузки пачки задач в общую очередь при переполнении локальной очереди.
